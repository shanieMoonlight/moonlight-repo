[
    {
        "id": "1",
        "title": "Spider Baby Mini-State",
        "content": "API palette SpiderBaby Mini-State APIComprehensive documentation and guides mini-state systemchange_historyMiniStateCore class for managing async operations with automatic handling of loading states, errors, and success messages.constructionMiniStateBuilderFactory for creating MiniState instances for common async operation patterns including reactive inputs.table_viewMiniCrudStateExtended MiniState for streamlined CRUD operations with automatic client-side data updates.merge_typeMiniStateCombinedUtility for combining multiple MiniState instances for unified loading, error, and success handling.handymanMiniStateUtilityHelper methods for working with multiple MiniState instances and combining their signals/observables.",
        "description": "A lightweight, signals-based state management library for Angular applications, handling loading states, errors, and success notifications while leveraging Angular's signals for reactivity.",
        "route": "/api/"
    },
    {
        "id": "2",
        "title": "Spider Baby Mini-State",
        "content": "API palette MiniState API Documentation MiniState is the core class of the mini-state library, providing a simple, signal-based state management solution for Angular applications. It handles async operations, loading states, errors, and success messages with a clean, declarative API. Note: The recommended way to initialize a MiniState is through the MiniStateBuilder. It simplifies the setup and ensures best practices are followed. Core ConceptConstructornew MiniState  constructor parametersCreates a new MiniState instance with the specified trigger  and optional parameters.Propertiesdata, loading, errorMsg, successMsgsignals and observablesMiniState provides both signals and observables for all state properties:data: Signal for the current data valueloading: Signal indicating  an operation is in progresserrorMsg: Signal for the current error message   any successMsg: Signal for the current success message   any data$: Observable for the data valueloading$: Observable for the loading stateerrorMsg$: Observable for error messagessuccessMsg$: Observable for success messagesMethodstrigger   and retrigger  initiating operationsMethods to initiate or repeat operations:trigger input : Initiates the async operation with the provided inputretrigger  : Repeats the most recent operation with the same inputunsubscribe  : Stops all ongoing operations and cleans up resourcesConfiguration Methodscustomizing behaviorMethods to customize MiniState behavior:setSuccessMsgFn fn : Sets a  that generates success messagessetOnTriggerFn fn : Sets a  that runs when trigger   is calledsetErrorMsgFn fn : Sets a  to convert errors to user-friendly messagesData Manipulationmodifying state directlyMethods to directly modify the data state:setData data : Sets the data value directlyupdateData updateFn : Updates data using a callback functionError Handlingmanaging errorsMethods for error management:setErrorMsg msg : Sets an error message directlyresetErrorMsg  : Clears the current error messageConfiguration MethodssetSuccessMsgFn  customize success messagesSets a  to generate custom success messages after successful operations.Will emit nothing  not setParticularly useful for operations like update or delete where user feedback is importantsetErrorMsgFn  customize error messagesSets a  to convert error objects to user-friendly error messages.If not set, defaults to extracting message or msg property from error objectsetSuccessDataProcessorFn  transform result dataSets a  to process and transform the raw output data before it's stored and emitted.Defaults to returning the data unchanged  not setGives access to input, output, previous input, and previous output valuesUseful for data transformation, filtering, or combining with existing datasetOnSuccessFn  actions after successSets a  to be called after a successful operation completes.Useful for triggering actions after a successful operation, such as navigation or starting another processExecutes after the data and success message have been emittedsetOnErrorFn  actions after errorSets a  to be called when an operation fails.Useful for handling specific error conditions, such as redirecting to an error pageExecutes after the error message has been emittedsetOnTriggerFn  actions before operationSets a  to be called when a trigger is initiated, before the async operation begins.Useful for pre-operation setup, validation, or loggingExecutes immediately when trigger   is called, before the async operation startsComplete ExampleThe following example demonstrates a complete user search component using MiniState:Just using  statements rather tha input triggered popups to demonstrate the functionality clearer",
        "description": "A lightweight, signals-based state management library for Angular applications, handling loading states, errors, and success notifications while leveraging Angular's signals for reactivity.",
        "route": "/api/mini-state/"
    },
    {
        "id": "3",
        "title": "Spider Baby Mini-State",
        "content": "API palette MiniStateBuilder API Documentation MiniStateBuilder provides a fluent API for creating MiniState instances with a clean, chainable syntax. It simplifies the process of configuring a MiniState and handles cleanup automatically via DestroyRef. Core Concept1. Select Factory MethodMiniStateBuilder.Create  CreateWithInput  CreateWithObservableInput  CreateWithSignalInput  2. Configure  Optional .setSuccessMsgFn ... .setErrorMsgFn ... 3. Use.trigger  MiniState manages state automaticallyFactory MethodsCreate static Create Output  triggerFn$:    =  Observable Output , initialOutputValue?: Output  Creates a MiniState for operations that don't require input parameters  e.g., \"get all\" operations . The trigger  takes no parameters. CreateWithInput static CreateWithInput Input, Output  triggerFn$:  input: Input  =  Observable Output , initialOutputValue?: Output  Creates a MiniState for operations that require input parameters  e.g., \"get by id\" or \"filtered search\" . The trigger  takes one parameter of type Input. CreateWithObservableInput static CreateWithObservableInput Input, Output  input$: Observable Input , triggerFn$:  input: Input  =  Observable Output , initialOutputValue?: Output  Creates a MiniState that automatically triggers whenever the input$ Observable emits a new value. Ideal for reacting to router parameters, form values, or other reactive data sources. CreateWithSignalInput static CreateWithSignalInput Input, Output  input$: Signal Input , triggerFn$:  input: Input  =  Observable Output , initialOutputValue?: Output  Creates a MiniState that automatically triggers whenever the input$ Signal changes. Similar to CreateWithObservableInput but for Angular's Signal primitive. Automatic Cleanup MiniStateBuilder automatically injects DestroyRef and sets up proper cleanup when the component is destroyed. This means you don't need to manually call unsubscribe   - subscriptions are managed for you. Complete ExamplesBasic ExampleWith Manual InputWith Observable InputA weather component that loads current weather data without input parameters:",
        "description": "A lightweight, signals-based state management library for Angular applications, handling loading states, errors, and success notifications while leveraging Angular's signals for reactivity.",
        "route": "/api/mini-state-builder/"
    },
    {
        "id": "4",
        "title": "Spider Baby Mini-State",
        "content": "API palette MiniStateCombined API Documentation MiniStateCombined is a utility class that enables aggregating multiple MiniState instances, giving you a unified way to track and display loading states, error messages, and success messages across related operations. OverviewKey Use Case: When your component performs multiple related operations  like load user details, update user, delete user , MiniStateCombined lets you show a single loading spinner, error message, or success message that represents the combined state of all operations.User Details StateUpdate User StateDelete User StateCombined StateCore MethodsCombine static Combine T extends MiniState any, any     ...states: T  Creates a combined state object that aggregates the state of multiple MiniState instances. The combined state provides signals and observables that reflect the collective state of all the input states.Utility MethodsCombineLoaders static CombineLoaders T extends MiniState any, any     ...states: T : Signal boolean  Creates a signal that is true  any of the input states are currently loading. This is useful for showing a single loading indicator for multiple operations.CombineErrorMsgs static CombineErrorMsgs T extends MiniState any, any     ...states: T : Signal string | undefined  Creates a signal that contains the most recent error message from any of the input states. Only one error message is displayed at a time, prioritizing the most recent.CombineSuccessMsgs static CombineSuccessMsgs T extends MiniState any, any     ...states: T : Signal string | undefined  Creates a signal that contains the most recent success message from any of the input states. Only one success message is displayed at a time, prioritizing the most recent.CombineData static CombineData T extends MiniState any, any     ...states: T : Signal any  Creates a signal that contains the most recent data from any of the input states. This is useful when multiple operations affect the same data model.CombineErrors static CombineErrors T extends MiniState any, any     ...states: T : Signal Error | undefined  Creates a signal that contains the most recent error object from any of the input states. This provides access to the actual error object for custom error handling.Complete Usage ExampleThe following example demonstrates a complete user profile component using MiniStateCombined to coordinate multiple user operations:",
        "description": "A lightweight, signals-based state management library for Angular applications, handling loading states, errors, and success notifications while leveraging Angular's signals for reactivity.",
        "route": "/api/mini-state-combined/"
    },
    {
        "id": "5",
        "title": "Spider Baby Mini-State",
        "content": "API palette MiniCrudState API Documentation MiniCrudState extends MiniState to provide specialized support for CRUD  Create, Read, Update, Delete  operations on collections of items. It handles client-side updates to the data array when items are added, updated, or deleted, making it perfect for building data management interfaces. OverviewKey Feature: MiniCrudState automatically maintains the client-side array of items when CRUD operations are performed. This means the UI will update immediately after add, update, or delete operations, without waiting for a subsequent reload of the data.Creating a MiniCrudStateCreate static Create Filter, Item  triggerFn$:  filter: Filter  =  Observable Item     Creates a new MiniCrudState instance for a collection of items that can be filtered.Configuration MethodssetAddState setAddState T  triggerFn$:  input: Item  =  Observable Item | undefined , successMsgFn?:  input: Item, output: Item | undefined  =  string, onTriggerFn?:  input: Item  =  void  Configures the add operation for the CRUD state. When an item is successfully added, it will automatically be appended to the items array in the state.setUpdateState setUpdateState T  triggerFn$:  input: Item  =  Observable Item | undefined , successMsgFn?:  input: Item, output: Item | undefined  =  string, onTriggerFn?:  input: Item  =  void  Configures the update operation for the CRUD state. When an item is successfully updated, the corresponding item in the array will be replaced with the updated version.setDeleteState setDeleteState DeleteResult  triggerFn$:  input: Item  =  Observable DeleteResult | undefined , successMsgFn:  input: Item, output: DeleteResult | undefined  =  string, onTriggerFn?:  input: Item  =  void  Configures the delete operation for the CRUD state. When an item is successfully deleted, it will automatically be removed from the items array in the state.setEqualsFn setEqualsFn equals?:  item1?: Item, item2?: Item  =  boolean  Sets the  used to determine  two items are equal. This is used when finding items to update or delete in the collection.Operation Methodstrigger filter: Filter  =  MiniState Filter, Item   Triggers the main operation to load the collection based on the provided filter.triggerAdd item: Item  =  MiniState Item, Item | undefined Triggers the add operation with the provided item. When successful, the item will be added to the collection in the state.triggerUpdate item: Item  =  MiniState Item, Item | undefined Triggers the update operation with the provided item. When successful, the item will be updated in the collection in the state.triggerDelete item: Item  =  MiniState Item, any Triggers the delete operation with the provided item. When successful, the item will be removed from the collection in the state.How It Works1Get All ItemsWhen you call trigger filter , MiniCrudState loads the entire collection based on the provided filter and replaces the current data array.2Add ItemWhen you call triggerAdd item , MiniCrudState:Calls the API to create the itemOn success, appends the new item to the existing data arrayNo additional fetch is needed to update the UI3Update ItemWhen you call triggerUpdate item , MiniCrudState:Calls the API to update the itemOn success, finds and replaces the matching item in the data arrayUses the equals  to find the matching item4Delete ItemWhen you call triggerDelete item , MiniCrudState:Calls the API to delete the itemOn success, removes the matching item from the data arrayUses the equals  to find the item to removeComplete Usage ExampleThe following example demonstrates a complete user management component using MiniCrudState:",
        "description": "A lightweight, signals-based state management library for Angular applications, handling loading states, errors, and success notifications while leveraging Angular's signals for reactivity.",
        "route": "/api/mini-state-crud/"
    },
    {
        "id": "6",
        "title": "Spider Baby Mini-State",
        "content": "API palette MiniStateUtility API Documentation The MiniStateUtility class provides static methods to combine and aggregate state from multiple MiniState instances. These utilities are useful for creating unified signals and observables for loading states, error messages, success messages, and data. Overview The MiniStateUtility class includes the following key methods: combineErrors: Combines error objects from multiple states.combineErrorMsgs: Combines error messages from multiple states.combineSuccessMsgs: Combines success messages from multiple states.combineLoading: Combines loading states from multiple states.combineData: Combines data from multiple states.ExamplescombineErrorsCombine error objectscombineErrorMsgsCombine error messagescombineSuccessMsgsCombine success messagescombineLoadingCombine loading statescombineDataCombine data",
        "description": "A lightweight, signals-based state management library for Angular applications, handling loading states, errors, and success notifications while leveraging Angular's signals for reactivity.",
        "route": "/api/ms-utility/"
    }
]