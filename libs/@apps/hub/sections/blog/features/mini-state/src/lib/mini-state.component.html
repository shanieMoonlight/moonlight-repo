<!-- ################################### -->

<ng-template #linksTemplate>
  <sb-hub-pkg-links 
    [gitHubRepoUrl]="_gitHubRepoUrl" 
    [npmPackageUrl]="_npmPackageUrl" 
    [demoWebsiteUrl]="_demoWebsiteUrl" />
</ng-template>

<sb-portal-input [portalTemplate]="linksTemplate" />

<!-- ################################### -->

<sb-notifications-modal-mat 
    [toastMsg]="_successMsg()" 
    [errorMsg]="_errorMsg()" />

<!-- ################################### -->

<sb-hub-hero-banner-2 
  [objectPosition]="'center 20%'"
  [title]="_title" 
  [subtitle]="_subtitle" 
  [description]="_description" 
  [backgroundImage]="_bannerImg" />

<div class="tutorial-content">

  <sb-hub-blog-ui-btn-download 
    [showButton]="_showButton()" 
    [loading]="_isLoading()" 
    [tooltip]="'Download Code Samples'"
    (downloadClick)="_dlClick$.next()" />  <section class="intro-section">
    <h2>ğŸ¤” The Universal Angular Challenge</h2>
    <p>
      Every Angular developer has faced this quintessential dilemma: orchestrating HTTP requests to external services
      while gracefully managing the intricate dance of loading states, success responses, error handling, and subscription lifecycles.
      This seemingly straightforward task often evolves into a complex web of boilerplate code and state management concerns.
    </p>
    
    <div class="challenge-explanation">
      <h3>The Essential Requirements:</h3>
      <ul>
        <li><strong>Asynchronous Service Communication</strong> - Seamlessly interface with APIs and external data sources</li>
        <li><strong>Progressive Loading Indicators</strong> - Provide intuitive visual feedback during pending operations</li>
        <li><strong>Graceful Success Orchestration</strong> - Elegantly present data upon successful completion</li>
        <li><strong>Sophisticated Error Handling</strong> - Deliver meaningful, user-friendly error messaging</li>
        <li><strong>Memory-Safe Subscription Management</strong> - Ensure proper resource cleanup to prevent memory leaks</li>
        <li><strong>Coordinated Multi-Operation Workflows</strong> - Harmoniously manage complex CRUD sequences and parallel operations</li>
      </ul>
    </div>    <div class="solution-highlight">
      <h3>ğŸ’¡ The Elegant MiniState Solution</h3>
      <p>
        <strong>MiniState</strong> emerges as a sophisticated yet lightweight solution that addresses these challenges with remarkable finesse.
        Unlike heavyweight alternatives such as &#64;ngrx/store, MiniState provides targeted, component-level state management
        specifically crafted for asynchronous operations, delivering enterprise-grade functionality without the complexity overhead.
      </p>
    </div>

    <h2>ğŸ•·ï¸ What You'll Learn</h2>
    <p>
      In this comprehensive tutorial, you'll master MiniState - a lightweight yet powerful state management library for Angular.
      MiniState simplifies async operations, loading states, error handling, and UI feedback using modern Angular patterns
      like Signals and RxJS observables.
    </p>

    <div class="benefits-grid">
      <div class="benefit-card">
        <h3>ğŸ¯ Reactive State Management</h3>
        <p>Handle async operations with built-in loading states and error handling</p>
      </div>
      <div class="benefit-card">
        <h3>ğŸ”„ Modern Angular Patterns</h3>
        <p>Built with Angular Signals and RxJS for optimal performance</p>
      </div>
      <div class="benefit-card">
        <h3>âš¡ CRUD Operations</h3>
        <p>Specialized support for Create, Read, Update, Delete operations</p>
      </div>
      <div class="benefit-card">
        <h3>ğŸ“¦ Git and NPM</h3>
        <sb-hub-pkg-links 
          [gitHubRepoUrl]="_gitHubRepoUrl" 
          [npmPackageUrl]="_npmPackageUrl" />
      </div>
    </div>
  </section>

  <mat-divider />

  <section class="getting-started-section">
    <h2>ğŸ› ï¸ What is MiniState?</h2>

    <div class="step-card">
      <p>
        MiniState is a lightweight state management library for Angular that focuses on simplifying async operations.
        Unlike complex global state libraries, MiniState is designed for component-level state management with:
      </p>
      <ul>
        <li><strong>Automatic Loading States</strong> - Built-in loading indicators for async operations</li>
        <li><strong>Error Handling</strong> - Centralized error management with customizable messages</li>
        <li><strong>Success Feedback</strong> - User-friendly success messages and callbacks</li>
        <li><strong>Signal Integration</strong> - Native Angular Signals support for reactive UI</li>
        <li><strong>Observable Support</strong> - Full RxJS integration for complex reactive patterns</li>
        <li><strong>Automatic Cleanup</strong> - Built-in resource management with DestroyRef</li>
      </ul>
    </div>
  </section>

  <section class="installation-section">
    <h2>ğŸ“¦ Installation</h2>
    
    <div class="code-card">
      <h3>Install MiniState</h3>
      <pre><code [highlight]="_installationExample" language="typescript"></code></pre>
    </div>

    <div class="code-card">
      <h3>Import in Your Component</h3>
      <pre><code [highlight]="_importExample" language="typescript"></code></pre>
    </div>
  </section>

  <mat-divider />

  <!-- Core Concepts Section -->
  <section class="concepts-section">
    <h2>ğŸ§  Core Concepts</h2>

    <div class="concept-explanation">
      <h3>What Problems Does MiniState Solve?</h3>
      <p>
        Traditional Angular async operations often require managing multiple pieces of state manually:
        loading flags, error states, success messages, and data. MiniState encapsulates all of this
        into a single, reactive state object that automatically handles these concerns.
      </p>
    </div>

    <div class="concept-explanation">
      <h3>Key Classes</h3>
      <ul>
        <li><strong>MiniState</strong> - Core class for managing async operation state</li>
        <li><strong>MiniStateBuilder</strong> - Factory for creating MiniState instances with different configurations</li>
        <li><strong>MiniCrudState</strong> - Specialized extension for CRUD operations on collections</li>
        <li><strong>MiniStateCombined</strong> - Combines multiple states for unified UI feedback</li>
        <li><strong>MiniStateUtility</strong> - Low-level utilities for fine-grained state combination</li>
      </ul>
    </div>

    <div class="concept-explanation">
      <h3>Signals vs Observables</h3>
      <p>
        MiniState provides both Angular Signals and RxJS Observables for all state properties:
      </p>
      <ul>
        <li><strong>Signals</strong> - Perfect for template binding and reactive computations</li>
        <li><strong>Observables</strong> - Ideal for complex reactive patterns and operators</li>
      </ul>
    </div>
  </section>

  <mat-divider />

  <!-- Basic Usage Section -->
  <section class="basic-usage-section">
    <h2>ğŸš€ Basic Usage</h2>

    <div class="example-card">
      <h3>Simple Data Fetching</h3>
      <p>The most basic MiniState usage for loading data without parameters:</p>
      <pre><code [highlight]="_basicExample" language="typescript"></code></pre>
    </div>

    <div class="example-card">
      <h3>Operations with Input Parameters</h3>
      <p>Handle operations that require input, like search or filtering:</p>
      <pre><code [highlight]="_withInputExample" language="typescript"></code></pre>
    </div>

    <div class="example-card">
      <h3>Reactive Operations</h3>
      <p>Automatically trigger operations when observables emit (like route parameters):</p>
      <pre><code [highlight]="_reactiveExample" language="typescript"></code></pre>
    </div>
  </section>

  <mat-divider />

  <!-- CRUD Operations Section -->
  <section class="crud-section">
    <h2>ğŸ“ CRUD Operations</h2>

    <div class="example-card">
      <h3>Complete CRUD with MiniCrudState</h3>
      <p>
        MiniCrudState extends MiniState to provide automatic handling of Create, Read, Update, Delete operations
        with client-side data synchronization:
      </p>
      <pre><code [highlight]="_crudExample" language="typescript"></code></pre>
    </div>
  </section>

  <mat-divider />

  <!-- Advanced Features Section -->
  <section class="advanced-section">
    <h2>ğŸ¯ Advanced Features</h2>

    <div class="example-card">
      <h3>Combining Multiple States</h3>
      <p>Use MiniStateCombined for unified loading indicators and error handling across multiple operations:</p>
      <pre><code [highlight]="_combinedStatesExample" language="typescript"></code></pre>
    </div>

    <div class="example-card">
      <h3>Granular State Control</h3>
      <p>Use MiniStateUtility for fine-grained control over state combinations:</p>
      <pre><code [highlight]="_stateUtilityExample" language="typescript"></code></pre>
    </div>

    <div class="example-card">
      <h3>Advanced Configuration</h3>
      <p>Customize every aspect of MiniState behavior with advanced configuration options:</p>
      <pre><code [highlight]="_advancedConfigExample" language="typescript"></code></pre>
    </div>
  </section>

  <mat-divider />

  <!-- Service Example Section -->
  <section class="service-section">
    <h2>ğŸ”§ Example Service</h2>

    <div class="code-card">
      <h3>Sample Service Implementation</h3>
      <p>Here's a complete service example that works with all the MiniState examples above:</p>
      <pre><code [highlight]="_userServiceExample" language="typescript"></code></pre>
    </div>
  </section>

  <mat-divider />

  <!-- Best Practices Section -->
  <section class="best-practices-section">
    <h2>ğŸ’¡ Best Practices</h2>

    <div class="practice-grid">
      <div class="practice-card">
        <h3>ğŸ¯ Use MiniStateBuilder</h3>
        <p>Always use MiniStateBuilder instead of instantiating MiniState directly. It handles DestroyRef injection automatically.</p>
      </div>
      
      <div class="practice-card">
        <h3>ğŸ”„ Expose Signals to Templates</h3>
        <p>Create protected properties that expose MiniState signals for template binding rather than accessing them directly.</p>
      </div>
      
      <div class="practice-card">
        <h3>ğŸ“¦ Combine Related Operations</h3>
        <p>Use MiniStateCombined for operations that should share loading states or error handling in the UI.</p>
      </div>
      
      <div class="practice-card">
        <h3>âš¡ Leverage Reactive Patterns</h3>
        <p>Use CreateWithObservableInput and CreateWithSignalInput for operations that should react to data changes.</p>
      </div>
    </div>
  </section>

  <mat-divider />

  <!-- Conclusion Section -->
  <section class="conclusion-section">
    <h2>ğŸ‰ Conclusion</h2>
    <p>
      You've now learned how to use MiniState for powerful, reactive state management in Angular! 
      This library provides a perfect middle ground between manual state management and complex global solutions.
      With built-in loading states, error handling, and modern Angular patterns, MiniState simplifies async
      operations while maintaining type safety and performance.
    </p>

    <div class="key-takeaways">
      <h3>ğŸ”‘ Key Takeaways</h3>
      <ul>
        <li>Use <strong>MiniStateBuilder</strong> for creating state instances</li>
        <li>Leverage <strong>Signals</strong> for reactive UI updates</li>
        <li>Use <strong>MiniCrudState</strong> for collection-based operations</li>
        <li>Combine states with <strong>MiniStateCombined</strong> for unified UI feedback</li>
        <li>Apply <strong>reactive patterns</strong> with Observable and Signal inputs</li>
      </ul>
    </div>

    <mat-divider/>
    
    <div class="npm-pkg-container">
      <h4>ğŸ¦¥ Ready to Get Started?</h4>
      <div class="npm-pkg-message">
        Install MiniState and start building reactive Angular applications:
        <sb-hub-pkg-links [npmPackageUrl]="_npmPackageUrl" />
      </div>
    </div>
    
    <mat-divider/>

    <div class="footer-cta">
      <p>Happy coding with MiniState! ğŸ•·ï¸âœ¨</p>
    </div>
  </section>
</div>